# TiDB SMP概要设计 #
## 一、概述 ##
SMP的主要目的在于充分利用系统资源，包括计算资源、IO资源，以提高查询效率。
SMP的主要难点在于并行任务的分配执行、并行任务之间的数据交互。

TiDB采用算子并行的方式实现SMP，其中，由于TiDB采用GO开发语言，并行任务之间的交互不是问题。TiDB主要关注并行任务的分配执行。

TiDB依次实现算子并行，首先实现表扫描算子（TableScan）、聚集算子（Agg）；然后实现排序算子（Sort）、连接算子（Join）等。
## 二、概要设计 ##
TiDB提供配置参数控制并行的最大数量，当参数被指定后，语句在执行时相关算子会并行执行，但是并行分配的go routine数量不能超过这个值。

TiDB的执行逻辑是pipeline方式，执行go routine沿着执行计划从上而下执行，执行数据自下而上返回。为了简化设计，TiDB对于一个执行计划只会选择代价最高的执行节点进行并行执行。比如下面的执行计划：

                    Agg                                 Agg
                     |                                   |	
                     |                                   |		
                    Join               -->              Stream  ———— 　Join1(t2: key(a-f))
                     /\                                         |
                    /  \                                        ———— 　Join2(t2: key(g-z))
         TableScan(t1)  TableScan(t2)

假设这段执行计划中的Agg、Join、TableScan都可以并行，TiDB会比较几个算子的代价，最后发现Join算子的代价最高，选择在Join算子上进行并行执行。这个时候执行计划会被改造，在原来Join算子的地方会替换成Stream算子，Stream算子会根据统计信息将Join任务切分成2份，执行时Stream算子负责启动两个go routine进行并行执行，Stream算子下面会有详细介绍。

在进行并行任务切分时，需要根据数据分布情况进行平均分配。这时就需要获取到表统计信息，统计信息越精确，并行任务分配的越均匀，并行执行的效率越高。

### 统计信息管理 ###
1.统计信息

表的统计信息保存在InfoSchema中,
需要新增结构体TableStatInfo，用于存储表中的数据的统计信息，结构体中的字段定义如下：

- name			string			//表名
- rowCount		int64			//表的记录数
- histogram		string			//统计直方图

histogram是表中key值的统计直方图，采用等频的存储方式，比如某表中的key值均匀分布，从aaa-faa，histogram中的值可能是（aaa,baa,caa,daa,eaa,faa)，每相邻两个值之间的记录数基本一样。


2.统计信息更新

TiDB在启动时会初始化一个go routine，周期性读取表的统计信息。通过调用统计接口将表的统计信息读取出来。可以在TiDB启动时指定统计信息周期更新的时间。在这个时间范围内，表的统计信息不变，如果统计信息有所变动，最新的统计信息可能会有一些延迟，不是很准确，这个影响不大。

3.统计接口

统计信息通过调用新增的存储接口来获取。

需要新增存储统计接口：

GetStatistic(t Key) (int64, []byte，error)

输入值：

	key ---- 表的key

返回值：

	int64 ---- 表的记录数

	[]byte ---- 统计直方图信息

	error ---- 错误信息

新增接口需要调用存储引擎的实现，存储引擎通过采样的方式估算出表的统计信息，包括表大小、key直方图信息。


### 查询计划生成与执行 ###
1.配置参数

需要添加一个配置参数：

- parallel\_max\_concurrency

并行分配的go routine的最大数量，默认0，表示不使用并行。
该参数可以动态修改。

2.计划生成

语句在经过语法分析之后，会进入到计划生成阶段，对于需要实现并行的算子，生成计划时的步骤如下：

1）判断是否需要并行

如果是索引扫描，不使用并行。

如果包含limit字句，不使用并行。

如果配置参数parallel\_max\_concurrency为0，不使用并行；

2）Stream算子

在确定需要将算子进行并行执行时，会新增Stream算子，Stream算子的作用是：

- 初始化执行状态，包括数据channel、并行数量、每个并行的执行计划等
- 负责启动并行go routine，将执行计划分别传给并行go routine执行
- 收集并行go routine执行过程中返回的执行数据
- 向上层算子返回执行数据，Stream算子仅仅传递数据，不做额外的处理。
- 并行go routine执行过程中的错误收集和处理，如果发现错误，整个查询返回，抛error
- 执行结束后，负责销毁并行执行过程的资源

3）生成并行计划

a.选择需要并行的算子，估算代价最高的算子做并行

在生成执行计划时对每个算子进行代价估算，算子的代价估算可以根据该算子要扫描的记录数、要进行的计算量等为依据。扫描的记录数一般从表的统计信息中估算；计算量一般按照特定的规则计算，比如聚集的计算代价、排序的计算代价、Join的计算代价、函数的计算代价等。

b.取出算子涉及到的表的统计信息，根据表的直方图信息并行划分，划分的并行数量不能超过parallel\_max\_concurrency。

c.并行任务划分完毕，修改执行计划。

执行算子分为阻塞性算子（比如Sort、Agg）和非阻塞性算子（比如TableScan、Join）。非阻塞型算子在下层返回一条数据后立刻做处理，处理完毕立刻返回上层。阻塞性算子会等到下层把所有数据都返回之后再进行处理，处理的结果再向上返回。

针对非阻塞型算子，在执行计划树中以Stream算子替换当前算子，Stream算子中保存并行数量以及每个并行的执行计划。比如：
	
          TableScan(t)      -->     Stream  ———— 　TableScan(t: key(a-b))
                                            |
                                            ———— 　TableScan(t: key(c-d))
                                            |
                                            ———— 　TableScan(t: key(e-f))

对某个TableScan(t)进行了并行任务划分，划分的结果是启动3个并行，针对表t，key并行扫描的区间分别是(a,b),(c,d),(e,f)。Stream算子中会保存TableScan(t:(a,b)),TableScan(t:(c,d)),TableScan(t:(e,f))。

针对阻塞性算子，在执行计划树中保持当前算子不变，在当前算子下层添加Stream算子，Stream算子中保存并行数量以及每个并行的执行计划。Stream算子将并行的数据向上返回给上层的阻塞性算子，上层阻塞性算子收到所有数据后做最终的计算。比如：
	
          Agg(t)      -->      Agg
                                |
                               Stream   ———— 　Agg(t: key(a-b))
                                        |
                                        ———— 　Agg(t: key(c-d))
                                        |
                                        ———— 　Agg(t: key(e-f))

对某个Agg(t)进行了并行任务划分，划分的结果是启动3个并行。Stream算子中会保存Agg(t:(a,b)),Agg(t:(c,d)),Agg(t:(e,f))。顶层的Agg算子会接受Stream算子传递回来的数据做最终的汇总计算，所以Agg算子的实现也需要针对并行相应做修改。

3.计划执行

计划的执行仍然是按照pipeline方式，非并行算子的执行逻辑不变，并行算子的执行逻辑如下：

1. 读取Stream算子，初始化执行状态（数据channel等）。
2. 根据并行数启动相应个数的go routine，并将并行执行计划分别指派给新routine执行。
3. 新启动的并行go routine初始化执行状态，开始执行Stream分配下来的执行计划，执行的结果传到指定的channel中。
4. 并行go routine在执行完毕后退出。
5. Stream算子不断从指定channel中读取数据，并将数据返回给上层算子，直到所有数据读取完毕。
6. Stream算子执行结束，清理执行资源。


# 参考资料 #
[https://github.com/forcedotcom/phoenix/issues/49](https://github.com/forcedotcom/phoenix/issues/49)